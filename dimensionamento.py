from copy import deepcopy
from typing import Optional

import pandas as pd
from anastruct import SystemElements

from utilitarios.analise_estrutural import executar_hipoteses_carregamento
from utilitarios.constantes import COEF_MINORACAO_PADRAO, LIMITE_TAXA_TRABALHO_DIAG_HORIZ, FATOR_ESMAGAMENTO_PADRAO
from utilitarios.ferramentas_montantes import (
    expandir_ligacoes_montantes_simetricos,
    identificar_montantes_com_ligacao,
    igualar_perfis_montantes_por_modulo,
    marcar_montantes_em_extremidades,
    reforcar_montante_ate_viavel
)
from utilitarios.geral import divisao_segura, ordenar_id_barra
from utilitarios.io_excel import (
    carregar_tabela_materiais,
    carregar_tabela_perfis,
    obter_fu,
    obter_fy,
    filtrar_por_diametro_parafuso
)
from utilitarios.ligacoes import (
    ajustar_perfis_montantes_por_ligacao,
    dimensionar_ligacao,
    otimizar_ligacoes_montantes_extremidades,
)
from utilitarios.peso import calcular_peso_por_modulo, calcular_peso_total
from utilitarios.verif_normativas import (
    calcula_tensao_axial_admissivel,
    calcular_esbeltez_corrigida,
    verifica_flexao_simples,
    verificar_axial_flexao,
)

from utilitarios.wrappers import wrapper_ligacao_montante

def dimensionar_barras(
    esforcos_por_hipotese: dict[str, dict[str, float]],
    estruturas_por_hipotese: dict[str, SystemElements],
    df_montantes: pd.DataFrame,
    df_diagonais_horizontais: pd.DataFrame,
    df_materiais: pd.DataFrame,
    df_perfis: pd.DataFrame,
    coef_minoracao: float = COEF_MINORACAO_PADRAO,
    diametros_furos: dict[str, float] | None = None,
    descontos_area_liquida: dict[str, int] | None = None,
    limite_parafusos: dict[str, int] | None = None,
    planos_cisalhamento: dict[str, int] | None = None,
    fatores_esmagamento: list[float] | None = None,
    interromper_se_inviavel: bool = True,
) -> tuple[
    Optional[dict[str, dict[str, any]]], Optional[dict[str, dict[str, any]]], Optional[set[str]],]:
    """
    Dimensiona **todas** as barras de uma treli√ßa submetida a diversas hip√≥teses de
    carregamento, contemplando:

    * resist√™ncia axial (tra√ß√£o e compress√£o) com limites de esbeltez distintos;
    * verifica√ß√£o de flex√£o simples para barras com |Œ±| ‚â§ 45 ¬∞;
    * verifica√ß√£o do limite absoluto de flambagem local (w/t ‚â§ 25 conforme ASCE 10-15);
    * compatibilidade com liga√ß√µes met√°licas parafusadas (cisalhamento e esmagamento);
    * simetria e unifica√ß√£o de perfis nos montantes de cada m√≥dulo;
    * refor√ßo iterativo do perfil quando a liga√ß√£o reprova, at√© converg√™ncia.

    O algoritmo √© dividido em nove etapas principais:

    1. **Prepara√ß√£o dos dados**
       Coleta os metadados de cada barra a partir das estruturas resolvidas (`SystemElements`),
       classificando o tipo de solicita√ß√£o (tra√ß√£o ou compress√£o) e registrando os comprimentos
       (real e destravado).
       Em seguida, os montantes s√£o classificados como **base de m√≥dulo**, **topo de m√≥dulo** ou
       **topo da estrutura**, com base em sua posi√ß√£o vertical relativa dentro de cada m√≥dulo.
       Essa marca√ß√£o √© usada como crit√©rio unificado para determinar **quais montantes exigem
       verifica√ß√£o de liga√ß√£o met√°lica nas extremidades da torre**.
       As barras marcadas s√£o replicadas para seus montantes sim√©tricos.

    2. **Pr√©-processamento por barra: tra√ß√£o exclusiva e hip√≥teses cr√≠ticas**
       Identifica quais barras est√£o exclusivamente tracionadas em todas as hip√≥teses,
       permitindo um crit√©rio de esbeltez mais permissivo para essas barras.
       Em seguida, para cada barra, elege-se a hip√≥tese que gera a **maior tra√ß√£o** e a que
       gera a **maior compress√£o**. Se alguma delas estiver ausente, o algoritmo
       introduz uma hip√≥tese simulada (`hip_0_t` ou `hip_0_c`) com esfor√ßo fict√≠cio de
       ¬±0,01 kgf para viabilizar os c√°lculos e garantir a consist√™ncia da sa√≠da.

    3. **Varredura de perfis (pr√©-cheque)**
        Para cada hip√≥tese cr√≠tica, o algoritmo executa:

    - Avalia√ß√£o de todos os perfis dispon√≠veis, filtrados de acordo com o tipo de barra:
          - Para montantes, s√£o exclu√≠dos perfis com nota ‚ÄúN√£o utilizar em montante! (Flambagem Local)‚Äù;
          - Todos os perfis devem possuir valor de ‚ÄúD m√°x‚Äù maior ou igual ao di√¢metro de parafuso exigido para a barra
        (ou ser√£o descartados).
        - Aplica√ß√£o sequencial dos seguintes crit√©rios:
          - Resist√™ncia axial combinada com limites de esbeltez.
          - Verifica√ß√£o de flex√£o simples (aplic√°vel quando |Œ±| ‚â§ 45¬∞).
          - **Liga√ß√µes m√≠nimas individuais** (*aplic√°vel apenas para diagonais e horizontais*): para cada perfil,
            percorre-se todos os pares poss√≠veis de `(np, fp)` dentro dos limites definidos por `limite_parafusos`
            e `fatores_esmagamento`, buscando o primeiro arranjo que satisfa√ßa **ambos** os crit√©rios:
            `F ‚â§ Fc` (cisalhamento) **e** `F ‚â§ Fe` (esmagamento).
            - Se o **cisalhamento** continuar limitante **mesmo com** `np = np_max`, o perfil √© **rejeitado** (aumentar a espessura n√£o resolve).
            - Se o **esmagamento** for limitante, testa-se `fp` at√© 1,25 antes de descartar.
          - Limita√ß√£o da taxa de trabalho a no m√°ximo 90% para diagonais e horizontais.
        - Sele√ß√£o do perfil leve mais vi√°vel para cada barra; caso nenhum atenda, registra-se como "NENHUM".

    4. **Escolha do perfil da barra**
       Quando as duas hip√≥teses resultam no mesmo perfil vi√°vel, ele √© adotado.
       Se resultam em perfis distintos, opta-se por aquele que:

       * apresentar a **maior taxa de trabalho** (crit√©rio de efici√™ncia); ou
       * possuir a **maior √°rea bruta** em caso de empate na taxa.

    5. **Rechecagem completa com o perfil final**
       Reexecuta os c√°lculos axiais, de flex√£o e da liga√ß√£o m√≠nima para ambas as
       hip√≥teses, agora utilizando o perfil final.
       Registra‚Äêse, para cada barra, a hip√≥tese que produz a maior
       `tx_lig` ‚Üí `pior_ligacao`.

    6. **Dimensionamento das liga√ß√µes definitivas (montantes)**
       Para cada extremidade de m√≥dulo s√£o avaliadas combina√ß√µes de par√¢metros
       (n¬∫ de parafusos, di√¢metro, planos de cisalhamento, fator de esmagamento)
       at√© encontrar **um √∫nico arranjo vi√°vel** que atenda simultaneamente ao par de
       montantes na extremidade.
       Se nenhuma liga√ß√£o vi√°vel for encontrada, o processo √© interrompido (ou retorna
       `None`, conforme o par√¢metro `interromper_se_inviavel`).
       O detalhamento √≥timo obtido √© propagado aos montantes sim√©tricos.

       * Aten√ß√£o: esse processo de abortar o dimensionamento em caso de liga√ß√£o
         invi√°vel √© exclusivo dos montantes, que exigem simetria e verifica√ß√£o
         conjunta nas extremidades dos m√≥dulos. Diagonais e horizontais s√£o
         dimensionadas individualmente; se nenhuma liga√ß√£o vi√°vel for poss√≠vel
         com o perfil atual, a barra √© apenas marcada como "NENHUM" e o processo
         segue normalmente para as demais.

    7. **Uniformiza√ß√£o e refor√ßo dos perfis dos montantes**

       Inicialmente, todos os montantes de um mesmo m√≥dulo recebem o **maior perfil**
       entre eles ap√≥s o dimensionamento preliminar. Essa iguala√ß√£o intram√≥dulo
       garante simetria estrutural e compatibilidade entre montantes de mesma altura.

       Em seguida, o algoritmo verifica as **liga√ß√µes nas extremidades** dos m√≥dulos
       (base e topo, √† esquerda e √† direita). Caso alguma liga√ß√£o reprove com o perfil atual,
       o algoritmo tenta refor√ßar iterativamente os perfis dos montantes cr√≠ticos,
       sempre adotando o **menor perfil superior dispon√≠vel** que satisfa√ßa a liga√ß√£o
       e os crit√©rios normativos.

       Durante esse processo, a liga√ß√£o mais exigente (entre tra√ß√£o e compress√£o)
       √© identificada e registrada como a **pior liga√ß√£o** da barra, para fins de relat√≥rio.

       Ap√≥s a converg√™ncia (ou ao fim das 10 tentativas), uma nova **iguala√ß√£o dos perfis**
       √© realizada para garantir a uniformidade intram√≥dulo ap√≥s o refor√ßo.

       Finalmente, todas as liga√ß√µes das extremidades s√£o **recalculadas** com os perfis finais,
       garantindo que os dados exibidos reflitam corretamente o perfil adotado.

       Se, ao final do processo, alguma liga√ß√£o ainda estiver invi√°vel, o algoritmo
       interrompe (ou retorna None, conforme o par√¢metro `interromper_se_inviavel`).

       Durante o refor√ßo dos montantes, s√£o considerados apenas os perfis previamente filtrados por:

        - Compatibilidade com o di√¢metro de parafuso (`D m√°x`), e

        - viabilidade pr√°tica de uso como montante, com base na coluna "Notas" da tabela de perfis:
          excluem-se perfis marcados como ‚ÄúN√£o utilizar em montante!‚Äù, por estarem sujeitos √† flambagem
          local significativa, cuja verifica√ß√£o normativa exigiria redu√ß√£o da tens√£o de escoamento (Fy).
          Essa restri√ß√£o √© adotada por crit√©rio de projeto pr√°tico, evitando o uso de perfis que, embora
          matematicamente vi√°veis, apresentariam desempenho estrutural inferior ou pouco eficiente.


    8. **C√°lculo das taxas finais para exibi√ß√£o**
       Determina-se, por barra:

       * `taxa_trabalho_final` ‚Üí maior entre N‚Çú/F‚Çê,‚Çú e Nùöå/F‚Çê,ùöå
       * `tx_lig_final`         ‚Üí maior entre N/Fc (cisalhamento) e N/Fe (esmagamento)

       Esses valores somente alimentam a impress√£o da tabela de resultados.

    9. **Sa√≠da consolidada**
       A fun√ß√£o devolve:

       * **resultado_final** ‚Äî dicion√°rio por barra, contendo:
         perfil adotado, hip√≥tese cr√≠tica axial, hip√≥tese cr√≠tica de liga√ß√£o,
         taxas finais, metadados de comprimento, √¢ngulo, m√≥dulo, etc.

       * **ligacoes_forcadas** ‚Äî detalhamento final das liga√ß√µes realmente
         executadas (ap√≥s iguala√ß√£o/otimiza√ß√£o).

       * **ids_ligacao_necessaria** ‚Äî conjunto com os IDs das barras
         efetivamente ligadas (√∫til para formata√ß√£o de relat√≥rios).

    -------
    Args:
        esforcos_por_hipotese (dict[str, dict[str, float]]):
            Esfor√ßos axiais `N` (kgf) em cada barra para cada nome de hip√≥tese
            (ex.: ``{"Fh(+)" : {"01": 500, "02": -300, ...}, "Fh(-)" : {...}}``).

        estruturas_por_hipotese (dict[str, SystemElements]):
            Objetos `anaStruct.SystemElements` j√° resolvidos, na mesma chave de
            `esforcos_por_hipotese`. S√£o usados apenas para extrair metadados.

        df_montantes (pd.DataFrame):
            Tabela de perfis dispon√≠veis para montantes (colunas m√≠nimas:
            ``Perfil``, ``A(cm2)``, ``rx(cm)``, ``Wx(cm3)``, ``t(cm)``, ``Peso(kg/m)``).

        df_diagonais_horizontais (pd.DataFrame):
            Tabela an√°loga para diagonais e horizontais (raio m√≠nimo = ``rz``).

        df_materiais (pd.DataFrame):
            Propriedades dos a√ßos (``Fy``, ``Fu``, ``fc`` ‚Äì parafuso).

        df_perfis (pd.DataFrame):
            Uni√£o de todas as tabelas de perfis (montantes ‚à™ diagonais/horiz.).

        coef_minoracao (float, opcional):
            Coeficiente de minora√ß√£o de resist√™ncia (Œ≥), padr√£o = 0,9.

        diametros_furos (dict[str, float], opcional):
            Di√¢metros de furo em cent√≠metros por tipo de barra
            (``{"montante": 1.27, "diagonal": 1.59, ...}``).

        descontos_area_liquida (dict[str, int], opcional):
            N√∫mero de furos descontados no c√°lculo de √°rea l√≠quida na tra√ß√£o
            (permite sobrescrever o valor da planilha).

        limite_parafusos (dict[str, int], opcional):
            Quantidade m√°xima de parafusos por barra (por tipo).

        planos_cisalhamento (dict[str, int], opcional):
            N.¬∫ de planos de cisalhamento considerados por tipo de barra.

        fatores_esmagamento (list[float], opcional):
            Sequ√™ncia de fatores multiplicativos (`f_p`) a testar no c√°lculo de
            esmagamento (ex.: ``[1.0833, 1.25]``).

        interromper_se_inviavel (bool, opcional):
            Se ``True`` (padr√£o), lan√ßa ``ValueError`` caso alguma barra n√£o
            encontre perfil vi√°vel; caso contr√°rio retorna ``None`` nos tr√™s
            resultados.

    Returns:
        tuple[Optional[dict[str, dict[str, any]]], Optional[dict[str, dict[str, any]]], Optional[set[str]]]:
        ``(resultado_final, ligacoes_forcadas, ids_ligacao_necessaria)``

            Uma tupla contendo:

            - **resultado_final**: Dicion√°rio com os dados finais de dimensionamento por barra, contendo o perfil adotado, verifica√ß√µes por hip√≥tese, taxas finais, entre outros.

            - **ligacoes_forcadas**: Dicion√°rio com os par√¢metros detalhados das liga√ß√µes adotadas para os montantes nas extremidades da torre.

            - **ids_ligacao_necessaria**: Conjunto com os IDs das barras que exigem liga√ß√£o met√°lica, geralmente nos topos e bases dos m√≥dulos.

            Os tr√™s elementos podem ser `None` caso `interromper_se_inviavel=False` e alguma barra resulte invi√°vel.

    Raises:
        ValueError: Se `interromper_se_inviavel=True` e ao menos uma barra ficar
        sem perfil vi√°vel ap√≥s a varredura completa.

    Nota:
        * O algoritmo **n√£o** tenta perfis maiores quando o cisalhamento √© o
          limitante mesmo com `np = np_max` ‚Äî isso evita itera√ß√µes in√∫teis com
          aumento de espessura que n√£o resolvem o problema.
        * Caso n√£o seja poss√≠vel dimensionar a liga√ß√£o de algum montante mesmo ap√≥s
          iguala√ß√£o e refor√ßo, a fun√ß√£o √© interrompida (ou retorna `None`, conforme
          `interromper_se_inviavel`).
        * O resultado √© totalmente independente de efeitos de peso‚Äêpr√≥prio; caso o
          Otimizador esteja em modo iterativo, ele deve **reexecutar** esta fun√ß√£o
          ap√≥s atualizar as cargas verticais, garantindo consist√™ncia de esfor√ßos,
          perfis e liga√ß√µes a cada ciclo.
        * Perfis com restri√ß√µes normativas ou incompat√≠veis com o di√¢metro de parafuso
          exigido s√£o automaticamente exclu√≠dos da sele√ß√£o de perfil, tanto no
          dimensionamento inicial quanto no refor√ßo dos montantes.

    """

    # === 1. Inicializa√ß√£o dos par√¢metros e coleta de metadados ===
    # Define par√¢metros padr√£o e extrai os metadados necess√°rios a partir das estruturas resolvidas
    # para cada hip√≥tese de carregamento. Tamb√©m classifica o tipo de solicita√ß√£o (tra√ß√£o/compress√£o)
    # e marca as extremidades relevantes dos montantes (base de m√≥dulo, topo de m√≥dulo, topo da estrutura).

    # Define os di√¢metros de furo padr√£o (em cm), caso n√£o tenham sido fornecidos
    if diametros_furos is None:
        diametros_furos = {"montante": 1.59, "diagonal": 1.59, "horizontal": 1.59}

    # Inicializa os dicion√°rios para tipos de solicita√ß√£o e metadados estruturais
    tipos_por_barra: dict[str, set[str]] = {}
    metadados_barras: dict[str, dict[str, any]] = {}

    # Percorre as hip√≥teses e acumula tipos de solicita√ß√£o por barra
    for nome_hipotese, barras_dict in esforcos_por_hipotese.items():
        estrutura = estruturas_por_hipotese[nome_hipotese]
        for id_barra, forca_axial in barras_dict.items():
            solicitacao = "tracao" if forca_axial > 0 else "compressao"
            tipos_por_barra.setdefault(id_barra, set()).add(solicitacao)

            # Extrai os metadados estruturais da barra (coordenadas, tipo, √¢ngulo, etc.)
            if id_barra not in metadados_barras:
                metadados_barras[id_barra] = estrutura.barras_para_dimensionar[id_barra]

    # Marca quais montantes est√£o nas extremidades (usado para identificar pontos de liga√ß√£o)
    marcar_montantes_em_extremidades(metadados_barras)

    # Identifica os montantes que exigem liga√ß√£o met√°lica (base de m√≥dulo ou topo da torre)
    # (montantes em topo de estrutura/base de m√≥dulo)
    ids_ligacao_necessaria = identificar_montantes_com_ligacao(
        metadados_barras, esforcos_por_hipotese
    )

    # Adiciona os montantes sim√©tricos √† verifica√ß√£o de liga√ß√£o
    ids_ligacao_necessaria = expandir_ligacoes_montantes_simetricos(
        metadados_barras, ids_ligacao_necessaria, tolerancia=1e-3
    )

    # === 2. Pr√©-processamento por barra: identifica√ß√£o de tra√ß√£o exclusiva e hip√≥teses cr√≠ticas ===

    # Identifica as barras que est√£o exclusivamente em tra√ß√£o
    barras_exclusivamente_tracionadas = {
        id_barra for id_barra, solicitacoes in tipos_por_barra.items() if solicitacoes == {"tracao"}
    }

    # Para cada barra, seleciona as hip√≥teses com pior tra√ß√£o e pior compress√£o, simulando se necess√°rio
    resultado_final = {}

    for id_barra, solicitacoes in tipos_por_barra.items():
        dados_barra = metadados_barras[id_barra]

        # Extrai os esfor√ßos de todas as hip√≥teses para esta barra
        esforcos_barra = {
            hip: barras.get(id_barra)
            for hip, barras in esforcos_por_hipotese.items()
            if id_barra in barras
        }

        # Simula√ß√£o antecipada de hip√≥teses faltantes
        forca_axial_simulada_minima = 0.01

        esforcos_barra = {
            hip: barras.get(id_barra)
            for hip, barras in esforcos_por_hipotese.items()
            if id_barra in barras
        }

        hipotese_critica_tracao = max(
            (hip for hip in esforcos_barra if esforcos_barra[hip] > 0),
            key=lambda h: esforcos_barra[h],
            default=None,
        )

        hipotese_critica_compressao = min(
            (hip for hip in esforcos_barra if esforcos_barra[hip] < 0),
            key=lambda h: esforcos_barra[h],
            default=None,
        )

        # Simula a hip√≥tese ausente, se necess√°rio
        if not hipotese_critica_tracao:
            esforcos_barra["hip_0_t"] = +forca_axial_simulada_minima
            esforcos_por_hipotese.setdefault("hip_0_t", {})[id_barra] = +forca_axial_simulada_minima
            hipotese_critica_tracao = "hip_0_t"

        if not hipotese_critica_compressao:
            esforcos_barra["hip_0_c"] = -forca_axial_simulada_minima
            esforcos_por_hipotese.setdefault("hip_0_c", {})[id_barra] = -forca_axial_simulada_minima
            hipotese_critica_compressao = "hip_0_c"

        barra_tem_forca_simulada = "hip_0_t" in esforcos_barra or "hip_0_c" in esforcos_barra

        # Cria dicion√°rio com apenas as hip√≥teses cr√≠ticas
        esforcos_filtrados: dict[str, float] = {}
        if hipotese_critica_tracao:
            esforcos_filtrados[hipotese_critica_tracao] = esforcos_barra[hipotese_critica_tracao]
        if hipotese_critica_compressao:
            esforcos_filtrados[hipotese_critica_compressao] = esforcos_barra[hipotese_critica_compressao]

        comprimento_real = dados_barra.get("comprimento")
        tipo_barra = dados_barra.get("tipo")
        angulo = dados_barra.get("alfa_graus", 0)

        if tipo_barra.startswith("montante"):
            comprimento_destravado = dados_barra.get("comprimento_destravado", comprimento_real)
        else:
            comprimento_destravado = comprimento_real

        comprimento = comprimento_destravado

        # Define qual tabela de perfis usar
        df_perf = df_montantes if tipo_barra.startswith("montante") else df_diagonais_horizontais

        # Filtro por di√¢metro de parafuso
        tipo_base = (
            "montante" if "montante" in tipo_barra
            else "diagonal" if "diagonal" in tipo_barra
            else "horizontal"
        )
        diametro_furo = diametros_furos.get(tipo_base, 1.59)

        df_perf = filtrar_por_diametro_parafuso(df_perf, diametro_furo)

        # Define limites de esbeltez conforme o caso da barra
        limitar_esbeltez_tracao = id_barra in barras_exclusivamente_tracionadas
        forcar_verificacao_compressao = not limitar_esbeltez_tracao

        # === 3. Dimensionamento ideal por hip√≥tese e verifica√ß√£o de flex√£o, esbeltez, liga√ß√£o e taxa ===

        melhores_por_hipotese: dict[str, dict[str, any]] = {}

        for nome_hipotese in esforcos_filtrados:
            forca_axial = esforcos_por_hipotese[nome_hipotese][id_barra]
            perfis_viaveis: list[dict[str, any]] = []

            for _, dados_perfil in df_perf.iterrows():
                # Determina tipo base (montante, diagonal ou horizontal)
                tipo_base = (
                    "montante"
                    if "montante" in tipo_barra
                    else "diagonal" if "diagonal" in tipo_barra else "horizontal"
                )

                # Define o di√¢metro de furo a ser considerado
                diametro_furo = diametros_furos.get(tipo_base, 1.59)

                # Verifica√ß√£o do limite absoluto de flambagem local (ASCE 10-15)
                # C√°lculo da rela√ß√£o w/t
                largura_aba = dados_perfil["b(cm)"]
                espessura_aba = dados_perfil["t(cm)"]
                raio_laminacao = dados_perfil["raio lam.(cm)"]

                largura_util = largura_aba - espessura_aba - raio_laminacao
                rel_w_t = largura_util / espessura_aba

                # Checagem do limite absoluto da norma
                if rel_w_t > 25:
                    continue  # Perfil reprovado por flambagem local (n√£o permitido pela ASCE 10-15)

                # Verifica√ß√£o de resist√™ncia axial conforme norma (compress√£o ou tra√ß√£o)
                verificacao_axial = calcula_tensao_axial_admissivel(
                    df_materiais,
                    dados_perfil,
                    forca_axial,
                    tipo_barra,
                    comprimento,
                    coef_minoracao,
                    diametro_furo=diametro_furo,
                    limitar_esbeltez_tracao=limitar_esbeltez_tracao,
                    forcar_verificacao_compressao=forcar_verificacao_compressao,
                    descontos_area_liquida=descontos_area_liquida,  # ‚Üê AQUI!
                )

                if not verificacao_axial["viavel"]:
                    continue  # perfil reprovado por resist√™ncia axial

                # Verifica√ß√£o de flex√£o
                modulo_resistencia_flexao_x = dados_perfil.get("Wx(cm3)", 0.0)
                tensao_fy = obter_fy(dados_perfil, df_materiais)

                flexao_ok = verifica_flexao_simples(
                    tipo_barra=tipo_barra,
                    angulo_graus=angulo,
                    comprimento=comprimento,
                    modulo_resistencia_flexao_x=modulo_resistencia_flexao_x,
                    tensao_fy=tensao_fy,
                    coef_minoracao=coef_minoracao,
                )

                if not flexao_ok:
                    continue  # perfil rejeitado por n√£o resistir √† flex√£o

                # Verifica√ß√£o de liga√ß√£o completa (usa np_max e fp at√© 1.25) para diagonais e horizontais

                if not tipo_barra.startswith("montante"):
                    verificacao_ligacao = dimensionar_ligacao(
                        forca_axial=forca_axial,
                        tipo_barra=tipo_barra,  # diagonal / horizontal
                        perfil_nome=dados_perfil["Perfil"],
                        espessura_aba=dados_perfil["t(cm)"],
                        diametros_furos=diametros_furos,
                        fv_parafuso=df_materiais.loc["A394", "fc (kgf/cm¬≤)"],
                        fu_peca=obter_fu(dados_perfil, df_materiais),
                        limite_parafusos=limite_parafusos,
                        planos_cisalhamento=planos_cisalhamento,
                        fatores_esmagamento=fatores_esmagamento,
                        df_perfis=df_perfis,
                        coef_minoracao=coef_minoracao,
                    )

                    if (
                        verificacao_ligacao.get("forca_adm_cisalhamento", 0) == 0
                        or verificacao_ligacao.get("forca_adm_esmagamento", 0) == 0
                    ):
                        continue  # pula perfil com liga√ß√£o imposs√≠vel

                    forca_normal = abs(forca_axial)
                    forca_adm_cisalhamento = verificacao_ligacao.get("forca_adm_cisalhamento", 0)
                    forca_adm_esmagamento = verificacao_ligacao.get("forca_adm_esmagamento", 0)
                    tx_lig = max(
                        forca_normal / forca_adm_cisalhamento if forca_adm_cisalhamento else 999,
                        forca_normal / forca_adm_esmagamento if forca_adm_esmagamento else 999,
                    )

                    if tx_lig > 1.0:
                        continue  # ‚Üí tenta o pr√≥ximo perfil

                # Se barra for diagonal ou horizontal e taxa > 90%, rejeita
                if (
                    tipo_barra.startswith("diagonal") or tipo_barra.startswith("horizontal")
                ) and verificacao_axial["taxa_trabalho"] > LIMITE_TAXA_TRABALHO_DIAG_HORIZ:
                    continue  # perfil reprovado por alta taxa de trabalho

                # Se passou por todas as verifica√ß√µes, adiciona aos vi√°veis
                perfis_viaveis.append(
                    {
                        "perfil": dados_perfil["Perfil"],
                        "peso": dados_perfil["Peso(kg/m)"],
                        "area": dados_perfil["A(cm2)"],
                        "raio": (
                            dados_perfil["rx(cm)"]
                            if tipo_barra.startswith("montante")
                            else dados_perfil["rz(cm)"]
                        ),
                        "verificacao_axial": verificacao_axial,
                        "modulo_resistencia_flexao_x": dados_perfil.get("Wx(cm3)", 0.0),
                    }
                )

            # Armazena o melhor perfil encontrado, ou marca como invi√°vel
            if not perfis_viaveis:
                melhores_por_hipotese[nome_hipotese] = {
                    "perfil_escolhido": "NENHUM",
                    "area_bruta": 0.0,
                    "viavel": False,
                    "forca_axial": forca_axial,
                    "tipo": tipo_barra,
                    "alfa": angulo,
                    "comprimento": comprimento,
                }
            else:
                melhor = min(perfis_viaveis, key=lambda x: x["peso"])
                melhores_por_hipotese[nome_hipotese] = {
                    **melhor["verificacao_axial"],
                    "verificacao_ligacao": (
                        verificacao_ligacao if not tipo_barra.startswith("montante") else {}
                    ),
                    "perfil_escolhido": melhor["perfil"],
                    "area_bruta": melhor["area"],
                    "viavel": True,
                    "forca_axial": forca_axial,
                    "tipo": tipo_barra,
                    "alfa": angulo,
                    "raio": melhor["raio"],
                    "modulo_resistencia_flexao_x": melhor["modulo_resistencia_flexao_x"],
                    "modulo": dados_barra.get("modulo"),
                    "comprimento": comprimento_real,
                    "comprimento_destravado": comprimento_destravado,
                }
            # Se nenhuma das hip√≥teses cr√≠ticas encontrou perfil vi√°vel
            if all(d.get("perfil_escolhido") == "NENHUM" for d in melhores_por_hipotese.values()):
                if interromper_se_inviavel:
                    raise ValueError(f"Nenhum perfil vi√°vel para a barra {id_barra}")
                else:
                    # Se, ao final da varredura desta barra, nenhuma hip√≥tese teve perfil vi√°vel
                    if not melhores_por_hipotese:
                        if interromper_se_inviavel:
                            raise ValueError(f"Nenhum perfil vi√°vel para a barra {id_barra}")
                        else:
                            # registra a barra como invi√°vel para que seja capturada mais tarde
                            resultado_final[id_barra] = {"perfil_escolhido": "NENHUM"}
                            continue

        # === 4. Escolha do perfil final considerando o pior caso entre as hip√≥teses ===
        hipoteses_resultantes = list(melhores_por_hipotese.items())

        if len(hipoteses_resultantes) == 1:
            # Apenas uma hip√≥tese considerada (ex: quando N = 0), adota-se diretamente
            hipotese_critica = hipoteses_resultantes[0][0]
        else:
            perf_hip0 = hipoteses_resultantes[0][1]["perfil_escolhido"]
            perf_hip1 = hipoteses_resultantes[1][1]["perfil_escolhido"]

            if perf_hip0 == perf_hip1:
                # perfis iguais ‚Üí seleciona a hip√≥tese com maior taxa de trabalho
                def area_trabalho(dados):
                    if dados["solicitacao"] == "compressao":
                        return abs(dados["forca_axial"]) / dados.get("Fa_reduzido", 1e-6)
                    elif dados["solicitacao"] == "tracao":
                        return abs(dados["forca_axial"]) / dados.get("ft_admissivel", 1e-6)
                    else:
                        return 0.0

                # Filtra apenas hip√≥teses com perfil vi√°vel
                hipoteses_viaveis = [
                    (nome, dados)
                    for nome, dados in melhores_por_hipotese.items()
                    if dados["perfil_escolhido"] != "NENHUM"
                ]
                if not hipoteses_viaveis:
                    continue  # nenhuma hip√≥tese vi√°vel para essa barra

                hipotese_critica = max(hipoteses_viaveis, key=lambda kv: area_trabalho(kv[1]))[0]
            else:
                # perfis diferentes ‚Üí escolhe aquele com maior √°rea bruta (mais robusto)
                hipotese_critica = max(
                    melhores_por_hipotese.items(), key=lambda kv: kv[1]["area_bruta"]
                )[0]

        # Aplica o perfil escolhido da hip√≥tese cr√≠tica
        perfil_final = melhores_por_hipotese[hipotese_critica]["perfil_escolhido"]

        # === 5. Verifica√ß√£o final do perfil escolhido em cada hip√≥tese extrema ===

        # Recalcula os dados do perfil adotado em ambas as hip√≥teses com seus respectivos esfor√ßos
        dados_perfil = None
        for df_perfil_origem in [df_montantes, df_diagonais_horizontais]:
            match = df_perfil_origem[df_perfil_origem["Perfil"].str.strip() == perfil_final.strip()]
            if not match.empty:
                dados_perfil = match.iloc[0]
                break

        # Recalcula os par√¢metros normativos para o perfil final em cada hip√≥tese cr√≠tica
        for nome_hipotese in esforcos_filtrados:
            forca_axial = esforcos_por_hipotese[nome_hipotese][id_barra]
            solicitacao = "tracao" if forca_axial > 0 else "compressao"

            tipo_base = (
                "montante"
                if "montante" in tipo_barra
                else "diagonal" if "diagonal" in tipo_barra else "horizontal"
            )
            diametro_furo = diametros_furos.get(tipo_base, 1.59)

            verificacao_axial = calcula_tensao_axial_admissivel(
                df_materiais,
                dados_perfil,
                forca_axial,
                tipo_barra,
                comprimento,
                coef_minoracao,
                diametro_furo=diametro_furo,
                limitar_esbeltez_tracao=(solicitacao == "tracao"),
                forcar_verificacao_compressao=(solicitacao == "compressao"),
                descontos_area_liquida=descontos_area_liquida,
            )

            espessura_aba_final = dados_perfil["t(cm)"]
            verificacao_ligacao_final = dimensionar_ligacao(
                forca_axial=forca_axial,
                tipo_barra=tipo_barra,
                perfil_nome=perfil_final,
                espessura_aba=espessura_aba_final,
                diametros_furos=diametros_furos,
                fv_parafuso=df_materiais.loc["A394", "fc (kgf/cm¬≤)"],
                fu_peca=obter_fu(dados_perfil, df_materiais),
                limite_parafusos=limite_parafusos,
                planos_cisalhamento=planos_cisalhamento,
                fatores_esmagamento=fatores_esmagamento,
                df_perfis=df_perfis,
                coef_minoracao=coef_minoracao,
            )

            # Calcula a taxa de trabalho da liga√ß√£o para essa hip√≥tese
            forca_normal = abs(forca_axial)
            forca_adm_cisalhamento = verificacao_ligacao_final.get("forca_adm_cisalhamento")
            forca_adm_esmagamento = verificacao_ligacao_final.get("forca_adm_esmagamento")
            tx_cis = forca_normal / forca_adm_cisalhamento if forca_adm_cisalhamento else 999
            tx_esm = forca_normal / forca_adm_esmagamento if forca_adm_esmagamento else 999
            verificacao_ligacao_final["tx_lig"] = max(tx_cis, tx_esm)

            # Adiciona a esbeltez corrigida, se ainda n√£o estiver presente
            raio_giracao = (
                dados_perfil["rx(cm)"]
                if tipo_barra.startswith("montante")
                else dados_perfil["rz(cm)"]
            )
            verificacao_axial["raio"] = raio_giracao
            verificacao_axial["esbeltez_corrigida"] = calcular_esbeltez_corrigida(
                tipo_barra, comprimento, raio_giracao
            )

            # Atualiza os dados da hip√≥tese com os resultados do perfil final adotado
            melhores_por_hipotese[nome_hipotese].update(
                {
                    **verificacao_axial,
                    "perfil_escolhido": perfil_final,
                    "verificacao_ligacao": verificacao_ligacao_final,
                    "raio": (
                        dados_perfil["rx(cm)"]
                        if tipo_barra.startswith("montante")
                        else dados_perfil["rz(cm)"]
                    ),
                    "area_bruta": dados_perfil["A(cm2)"],
                    "comprimento": comprimento_real,
                    "comprimento_destravado": comprimento_destravado,
                    "forca_axial": forca_axial,
                    "tipo": tipo_barra,
                    "modulo": dados_barra.get("modulo"),
                    "solicitacao": "tracao" if forca_axial > 0 else "compressao",
                    "alfa": angulo,
                }
            )

            if nome_hipotese.startswith("hip_0"):
                melhores_por_hipotese[nome_hipotese]["simulada"] = True

        # Identifica a hip√≥tese cr√≠tica considerando a liga√ß√£o (maior taxa de trabalho da liga√ß√£o)
        hipotese_critica_ligacao = max(
            melhores_por_hipotese.items(),
            key=lambda item: item[1].get("verificacao_ligacao", {}).get("tx_lig", 0),
        )[0]

        # Salva os resultados da barra no dicion√°rio final
        resultado_final[id_barra] = {
            "pior_caso": hipotese_critica,
            "pior_ligacao": hipotese_critica_ligacao,
            "perfil_escolhido": perfil_final,
            "forcado_forca_simulada": barra_tem_forca_simulada,
            "hipotese_tracao": hipotese_critica_tracao or "hip_0_t",
            "hipotese_compressao": hipotese_critica_compressao or "hip_0_c",
            **{
                nome_hipotese: melhores_por_hipotese[nome_hipotese]
                for nome_hipotese in melhores_por_hipotese
            },
        }

    # Verifica se houve alguma barra sem perfil vi√°vel (tratamento de exce√ß√£o)
    barras_sem_perfil = [
        id_barra
        for id_barra, dados_barra in resultado_final.items()
        if dados_barra.get("perfil_escolhido") == "NENHUM"
    ]

    if barras_sem_perfil:
        mensagem = f"Dimensionamento invi√°vel! As barras a seguir n√£o obtiveram perfil: {barras_sem_perfil}"
        if interromper_se_inviavel:
            raise ValueError(mensagem)
        else:
            print(mensagem)
            return None, None, None

    # Atualiza metadados com o perfil final escolhido
    for id_barra, dados in resultado_final.items():
        nome_hipotese_critica = dados["pior_caso"]
        perfil = dados[nome_hipotese_critica]["perfil_escolhido"]
        metadados_barras[id_barra]["perfil_escolhido"] = perfil

    # === 6. Dimensionamento das liga√ß√µes definitivas nos montantes com liga√ß√£o real ===

    # Recalcula as liga√ß√µes com base nos perfis finais definidos
    ligacoes_forcadas = otimizar_ligacoes_montantes_extremidades(
        metadados_barras,
        esforcos_por_hipotese,
        df_materiais,
        diametros_furos,
        limite_parafusos,
        planos_cisalhamento,
        fatores_esmagamento,
        df_perfis,
        coef_minoracao=coef_minoracao,
    )

    # Se alguma liga√ß√£o de montante for invi√°vel, interrompe o processo (ou retorna None)
    if any(not lig.get("ligacao_viavel", True) for lig in ligacoes_forcadas.values()):
        if interromper_se_inviavel:
            raise ValueError("Pelo menos uma liga√ß√£o de montante ficou invi√°vel.")
        else:
            return None, None, None

    # Expandindo para sim√©tricos e injetando no resultado final:
    for id_base, lig in ligacoes_forcadas.items():
        ids_simetricos = expandir_ligacoes_montantes_simetricos(
            metadados_barras, {id_base}, tolerancia=1e-3
        )
        for id_barra in ids_simetricos:
            if id_barra not in resultado_final or id_barra not in ligacoes_forcadas:
                continue

            nome_hipotese_critica = resultado_final[id_barra]["pior_caso"]
            caso = resultado_final[id_barra][nome_hipotese_critica]

            forca_axial = abs(caso["forca_axial"])
            perfil_nome = caso["perfil_escolhido"]

            linha = df_perfis[df_perfis["Perfil"].str.strip() == perfil_nome.strip()]
            if linha.empty:
                continue

            linha = linha.iloc[0]
            espessura_aba = linha["t(cm)"]
            fu = obter_fu(linha, df_materiais)

            lig = ligacoes_forcadas[id_barra]
            diametro_furo = lig["d_furo"]
            qtd_parafusos = lig["np"]
            fator_fp = lig["fator_fp"]
            forca_adm_cisalhamento = lig["forca_adm_cisalhamento"]

            forca_adm_esmagamento_corrigido = (
                qtd_parafusos * diametro_furo * espessura_aba * fator_fp * fu * coef_minoracao
            )
            tx_cisalhamento = (
                forca_axial / forca_adm_cisalhamento if forca_adm_cisalhamento else 999
            )
            tx_esmagamento = (
                forca_axial / forca_adm_esmagamento_corrigido
                if forca_adm_esmagamento_corrigido
                else 999
            )
            tx_ligacao = max(tx_cisalhamento, tx_esmagamento)

            nova_ligacao = deepcopy(lig)
            nova_ligacao["forca_adm_esmagamento"] = forca_adm_esmagamento_corrigido
            nova_ligacao["tx_lig"] = tx_ligacao

            resultado_final[id_barra][nome_hipotese_critica]["verificacao_ligacao"] = nova_ligacao

    # === 7. Ajuste final de perfil por liga√ß√£o e simetriza√ß√£o entre montantes ===

    # 7-1. Igualar perfis dos montantes dentro de cada m√≥dulo
    igualar_perfis_montantes_por_modulo(
        resultado_final,
        df_montantes,
        df_materiais,
        coef_minoracao,
        diametros_furos,
        descontos_area_liquida=descontos_area_liquida,
    )

    # 7-2. Refor√ßo iterativo por liga√ß√£o at√© tx_lig ‚â§ 1,0 **e**
    #      todos os crit√©rios normativos passarem (m√°x 10 ciclos)
    barras_reforcadas: set[str] = set()

    for tentativa in range(10):
        ligacoes_iter: dict[str, dict] = {}
        todos_ok = True

        for id_barra in sorted(ids_ligacao_necessaria, key=ordenar_id_barra):
            # pula barras que n√£o chegaram a ser dimensionadas
            if id_barra not in resultado_final or resultado_final[id_barra].get("perfil_escolhido") == "NENHUM":
                todos_ok = False
                continue
            nome_hip = resultado_final[id_barra]["pior_caso"]
            caso = resultado_final[id_barra][nome_hip]
            perfil_ini = caso["perfil_escolhido"]
            N = abs(caso["forca_axial"])

            tipo_barra = metadados_barras[id_barra]["tipo"]
            angulo = metadados_barras[id_barra].get("alfa_graus", 0.0)
            if tipo_barra.startswith("montante"):
                comprimento = metadados_barras[id_barra].get(
                    "comprimento_destravado",
                    metadados_barras[id_barra]["comprimento"],
                )
            else:
                comprimento = metadados_barras[id_barra]["comprimento"]

            reforco = reforcar_montante_ate_viavel(
                id_barra=id_barra,
                perfil_atual=perfil_ini,
                forca_axial=N,
                df_perfis=df_perfis,
                df_materiais=df_materiais,
                diametros_furos=diametros_furos,
                limite_parafusos=limite_parafusos,
                planos_cisalhamento=planos_cisalhamento,
                fatores_esmagamento=fatores_esmagamento,
                coef_minoracao=coef_minoracao,
                descontos_area_liquida=descontos_area_liquida,
                criterios_norma_fn=verificar_axial_flexao,
                criterios_ligacao_fn=wrapper_ligacao_montante,
                tipo_barra=tipo_barra,
                comprimento=comprimento,
                angulo_graus=angulo,
                interromper_se_inviavel=interromper_se_inviavel,
            )

            # ‚Äî se None: a fun√ß√£o j√° marcou invi√°vel ou lan√ßou exce√ß√£o ‚Äî
            if reforco:
                novo_perfil, dados_lig = reforco
                caso["perfil_escolhido"] = novo_perfil
                caso["verificacao_ligacao"] = dados_lig
                ligacoes_iter[id_barra] = dados_lig
            else:
                todos_ok = False

        ligacoes_forcadas.update(ligacoes_iter)  # acumula liga√ß√µes definitivas

        for id_barra, lig in ligacoes_iter.items():
            # recalcula a hip√≥tese que agora tem maior tx_lig
            nome_pior = max(
                resultado_final[id_barra],
                key=lambda hip: isinstance(resultado_final[id_barra][hip], dict)
                                and resultado_final[id_barra][hip]
                                .get("verificacao_ligacao", {})
                                .get("tx_lig", 0),
            )
            resultado_final[id_barra]["pior_ligacao"] = nome_pior

        barras_reforcadas |= set(ligacoes_iter)  # idem para barras

        if todos_ok:
            break  # todas as barras passaram liga√ß√£o + norma

    else:  # executa se o for terminar sem break
        if interromper_se_inviavel:
            raise ValueError("Refor√ßo de liga√ß√£o n√£o convergiu em 10 ciclos.")
        return None, None, None

    # 7-3. Revalida√ß√£o normativa das barras refor√ßadas
    if barras_reforcadas:
        for id_barra in sorted(barras_reforcadas, key=ordenar_id_barra):
            dados_barra = metadados_barras[id_barra]
            tipo_barra: str = dados_barra["tipo"]
            angulo = dados_barra.get("alfa_graus", 0.0)
            comp_real = dados_barra["comprimento"]
            comp_destravado = dados_barra.get("comprimento_destravado", comp_real)
            comprimento = comp_destravado if tipo_barra.startswith("montante") else comp_real

            tipo_base = (
                "montante" if "montante" in tipo_barra
                else "diagonal" if "diagonal" in tipo_barra
                else "horizontal"
            )
            diametro_furo = diametros_furos.get(tipo_base, 1.59)

            for nome_hipotese, dados_hip in resultado_final[id_barra].items():
                if not isinstance(dados_hip, dict):
                    continue  # pula campos auxiliares

                perfil_nome = dados_hip["perfil_escolhido"]
                if perfil_nome == "NENHUM":
                    continue

                dados_perfil = df_perfis.loc[
                    df_perfis["Perfil"].str.strip() == perfil_nome.strip()
                ].iloc[0]

                forca_axial = esforcos_por_hipotese[nome_hipotese][id_barra]

                limitar_esbeltez_tracao = (
                    id_barra in barras_exclusivamente_tracionadas
                    and dados_hip["solicitacao"] == "tracao"
                )
                verificacao_axial = calcula_tensao_axial_admissivel(
                    df_materiais=df_materiais,
                    dados_perfil=dados_perfil,
                    forca_axial=forca_axial,
                    tipo_barra=tipo_barra,
                    comprimento_efetivo=comprimento,
                    coef_minoracao=coef_minoracao,
                    diametro_furo=diametro_furo,
                    limitar_esbeltez_tracao=limitar_esbeltez_tracao,
                    forcar_verificacao_compressao=not limitar_esbeltez_tracao,
                    descontos_area_liquida=descontos_area_liquida,
                )

                flexao_ok = verifica_flexao_simples(
                    tipo_barra=tipo_barra,
                    angulo_graus=angulo,
                    comprimento=comprimento,
                    modulo_resistencia_flexao_x=dados_perfil.get("Wx(cm3)", 0.0),
                    tensao_fy=obter_fy(dados_perfil, df_materiais),
                    coef_minoracao=coef_minoracao,
                )

                barra_viavel = verificacao_axial["viavel"] and flexao_ok

                if not barra_viavel:
                    dados_hip["viavel"] = False
                    dados_hip["verificacao_axial"] = verificacao_axial
                    dados_hip["tx_flexao"] = 999.0 if not flexao_ok else 0.0

                    msg = (
                        f"Ap√≥s refor√ßo da liga√ß√£o, a barra {id_barra} "
                        f"reprovou em {nome_hipotese}."
                    )
                    if interromper_se_inviavel:
                        raise ValueError(msg)
                    continue

                dados_hip.update(
                    {
                        "verificacao_axial": verificacao_axial,
                        "tx_trabalho": verificacao_axial["taxa_trabalho"],
                        "ft_admissivel": verificacao_axial.get("ft_admissivel"),
                        "Fa_reduzido": verificacao_axial.get("Fa_reduzido"),
                        "viavel": True,
                    }
                )
    # 7-4. Segunda iguala√ß√£o dos perfis dos montantes por m√≥dulo
    igualar_perfis_montantes_por_modulo(
        resultado_final,
        df_montantes,
        df_materiais,
        coef_minoracao,
        diametros_furos,
        descontos_area_liquida=descontos_area_liquida,
    )

    # ‚Äî Atualiza liga√ß√µes com os perfis j√° igualados ‚Äî
    ligacoes_forcadas = otimizar_ligacoes_montantes_extremidades(
        metadados_barras,
        esforcos_por_hipotese,
        df_materiais,
        diametros_furos,
        limite_parafusos,
        planos_cisalhamento,
        fatores_esmagamento,
        df_perfis,
        coef_minoracao,
    )
    for id_barra, lig in ligacoes_forcadas.items():
        nome_hip = resultado_final[id_barra]["pior_caso"]
        resultado_final[id_barra][nome_hip]["verificacao_ligacao"] = lig

    # 7-5. Verifica√ß√£o final das liga√ß√µes (abortiva)
    for id_barra in ids_ligacao_necessaria:
        nome_lig = resultado_final[id_barra].get("pior_ligacao")
        if not nome_lig:
            continue

        lig = resultado_final[id_barra].get(nome_lig, {}).get("verificacao_ligacao")
        if lig and lig.get("tx_lig", 0) > 1.0:
            if interromper_se_inviavel:
                raise ValueError(
                    f"Liga√ß√£o da barra {id_barra} ainda reprovada ap√≥s refor√ßo."
                )
            else:
                return None, None, None

    # === 8. Recalcula a pior taxa de trabalho axial e de liga√ß√£o com base nos esfor√ßos extremos ===

    for id_barra, dados in resultado_final.items():
        perfil = dados["perfil_escolhido"]
        if perfil == "NENHUM":
            continue

        dados_perfil = df_perfis[df_perfis["Perfil"].str.strip() == perfil.strip()]
        if dados_perfil.empty:
            continue
        dados_perfil = dados_perfil.iloc[0]

        tipo = next((d["tipo"] for d in dados.values() if isinstance(d, dict) and "tipo" in d), "")
        comprimento_destravado = next(
            (
                d["comprimento_destravado"]
                for d in dados.values()
                if isinstance(d, dict) and "comprimento_destravado" in d
            ),
            1,
        )

        d_furo = diametros_furos.get(
            (
                "montante"
                if "montante" in tipo
                else "diagonal" if "diagonal" in tipo else "horizontal"
            ),
            1.59,
        )

        # Recalcula for√ßa admiss√≠vel para tra√ß√£o e compress√£o com o perfil final
        forca_normal_tracao = max(
            [
                hip.get("forca_axial", 0)
                for hip in dados.values()
                if isinstance(hip, dict) and hip.get("forca_axial", 0) > 0
            ],
            default=0,
        )
        forca_normal_compressao = min(
            [
                hip.get("forca_axial", 0)
                for hip in dados.values()
                if isinstance(hip, dict) and hip.get("forca_axial", 0) < 0
            ],
            default=0,
        )

        forca_admissivel_tracao = calcula_tensao_axial_admissivel(
            df_materiais,
            dados_perfil,
            forca_axial=forca_normal_tracao,
            tipo_barra=tipo,
            comprimento_efetivo=comprimento_destravado,
            coef_minoracao=coef_minoracao,
            diametro_furo=d_furo,
            limitar_esbeltez_tracao=True,
            forcar_verificacao_compressao=False,
            descontos_area_liquida=descontos_area_liquida,
        ).get("forca_axial_admissivel", 1e-6)
        forca_admissivel_compressao = calcula_tensao_axial_admissivel(
            df_materiais,
            dados_perfil,
            forca_axial=forca_normal_compressao,
            tipo_barra=tipo,
            comprimento_efetivo=comprimento_destravado,
            coef_minoracao=coef_minoracao,
            diametro_furo=d_furo,
            limitar_esbeltez_tracao=False,
            forcar_verificacao_compressao=True,
            descontos_area_liquida=descontos_area_liquida,
        ).get("forca_axial_admissivel", 1e-6)

        tx_axial_trac = (
            abs(forca_normal_tracao) / forca_admissivel_tracao if forca_admissivel_tracao else 0
        )
        tx_axial_comp = (
            abs(forca_normal_compressao) / forca_admissivel_compressao
            if forca_admissivel_compressao
            else 0
        )
        dados["taxa_trabalho_final"] = max(tx_axial_trac, tx_axial_comp)

        # Recalcula taxas de liga√ß√£o com a liga√ß√£o final da barra
        lig = dados.get(dados.get("pior_ligacao", ""), {}).get("verificacao_ligacao")
        if not lig:
            continue  # n√£o h√° liga√ß√£o para essa barra

        forca_admissivel_cisalhamento = lig.get("forca_adm_cisalhamento", 1)
        forca_admissivel_esmagamento = lig.get("forca_adm_esmagamento", 1)

        tx_lig_trac = (
            max(
                divisao_segura(abs(forca_normal_tracao), forca_admissivel_cisalhamento),
                divisao_segura(abs(forca_normal_tracao), forca_admissivel_esmagamento),
            )
            if forca_normal_tracao
            else 0
        )
        tx_lig_comp = (
            max(
                divisao_segura(abs(forca_normal_compressao), forca_admissivel_cisalhamento),
                divisao_segura(abs(forca_normal_compressao), forca_admissivel_esmagamento),
            )
            if forca_normal_tracao
            else 0
        )
        dados["tx_lig_final"] = max(tx_lig_trac, tx_lig_comp)

    # === 9. Retorno dos resultados finais do dimensionamento ===
    return resultado_final, ligacoes_forcadas, ids_ligacao_necessaria

